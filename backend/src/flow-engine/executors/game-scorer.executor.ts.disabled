/**
 * Game Scorer Executor
 * 
 * Scores user responses in training games
 * - Calculates quality score (0-100)
 * - Saves to nlu_training_data table
 * - Returns score + rewards
 */

import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../database/prisma.service';
import { FlowContext } from '../types/flow.types';

export interface GameScorerConfig {
  missionType: string;
  expectedIntent: string;
  keywords: string[];
  minLength: number;
  maxReward: number;
  baseReward: number;
  requireHinglish?: boolean;
}

export interface GameScore {
  score: number; // 0-100
  points: number; // Mangwale points
  rupees: number; // Wallet credit
  feedback: string;
  quality: 'excellent' | 'good' | 'ok' | 'poor';
}

@Injectable()
export class GameScorerExecutor {
  private readonly logger = new Logger(GameScorerExecutor.name);

  constructor(private readonly prisma: PrismaService) {}

  async execute(
    context: FlowContext,
    config: GameScorerConfig,
    userInput: string,
  ): Promise<{ success: boolean; data: GameScore }> {
    this.logger.log(`Scoring game response: ${config.missionType}`);

    const text = userInput.trim();
    
    // Calculate score
    const score = this.calculateScore(text, config);
    
    // Determine if passing
    const passing = score >= 60;
    
    if (!passing) {
      return {
        success: false,
        data: {
          score,
          points: 0,
          rupees: 0,
          feedback: this.getFeedback(score),
          quality: this.getQuality(score),
        },
      };
    }

    // Calculate rewards based on score
    const points = Math.floor((score / 100) * config.maxReward);
    const rupees = Math.floor(points / 10); // ‚Çπ1 per 10 points

    // Save to training data
    await this.saveTrainingData(text, config, score, context);

    // Store in context for reward executor
    context.data.lastGameScore = score;
    context.data.lastGamePoints = points;
    context.data.lastGameRupees = rupees;

    return {
      success: true,
      data: {
        score,
        points,
        rupees,
        feedback: this.getFeedback(score),
        quality: this.getQuality(score),
      },
    };
  }

  /**
   * Calculate quality score (0-100)
   */
  private calculateScore(text: string, config: GameScorerConfig): number {
    let score = 60; // Base score for trying

    const lowerText = text.toLowerCase();

    // 1. Length bonus/penalty
    if (text.length >= config.minLength) {
      score += 10;
    }
    if (text.length >= config.minLength * 2) {
      score += 5; // Detailed responses
    }
    if (text.length < config.minLength) {
      score -= 20; // Too short
    }

    // 2. Keyword matching
    const matchedKeywords = config.keywords.filter(keyword =>
      lowerText.includes(keyword.toLowerCase())
    );
    const keywordScore = (matchedKeywords.length / config.keywords.length) * 20;
    score += keywordScore;

    // 3. Natural language indicators
    const naturalIndicators = [
      'chahiye', 'mangwa', 'bhej', 'karo', 'de do', 'hai', 'kaha',
      'please', 'bhai', 'yaar', 'arrey', 'jaldi',
    ];
    const naturalMatches = naturalIndicators.filter(ind =>
      lowerText.includes(ind)
    );
    score += naturalMatches.length * 3; // Up to 15 points

    // 4. Hinglish detection (if required)
    if (config.requireHinglish) {
      const hasHindi = /[\u0900-\u097F]/.test(text) || 
                       /chahiye|mangwa|bhej|kaha|karo|hai|yaar|bhai/.test(lowerText);
      const hasEnglish = /[a-zA-Z]/.test(text);
      
      if (hasHindi && hasEnglish) {
        score += 10; // Perfect Hinglish!
      } else if (!hasHindi && !hasEnglish) {
        score -= 15; // No recognizable text
      }
    }

    // 5. Penalize generic/robotic responses
    const roboticPhrases = [
      'i want to', 'please do', 'kindly', 'i would like',
      'point a', 'point b', 'location a', 'location b',
    ];
    const roboticMatches = roboticPhrases.filter(phrase =>
      lowerText.includes(phrase)
    );
    score -= roboticMatches.length * 10;

    // 6. Penalize very short responses
    if (text.length < 5) {
      score -= 30;
    }

    // 7. Bonus for specificity
    const specificTerms = [
      'dominos', 'burger king', 'paradise', 'mcdonalds',
      'gangapur', 'college road', 'nashik road', 'satpur',
      'bike', 'car', 'urgent', '3pm', 'tomorrow',
    ];
    const specificMatches = specificTerms.filter(term =>
      lowerText.includes(term.toLowerCase())
    );
    score += specificMatches.length * 5;

    // Clamp to 0-100
    return Math.max(0, Math.min(100, Math.round(score)));
  }

  /**
   * Get quality rating
   */
  private getQuality(score: number): 'excellent' | 'good' | 'ok' | 'poor' {
    if (score >= 90) return 'excellent';
    if (score >= 75) return 'good';
    if (score >= 60) return 'ok';
    return 'poor';
  }

  /**
   * Get feedback message
   */
  private getFeedback(score: number): string {
    if (score >= 90) return 'üåü Perfect! Very natural!';
    if (score >= 75) return '‚ú® Great job! Natural response!';
    if (score >= 60) return 'üëç Good! Could be more specific.';
    if (score >= 40) return 'üòÖ Try being more natural.';
    return '‚ùå Too generic. Add more details!';
  }

  /**
   * Save to nlu_training_data table
   */
  private async saveTrainingData(
    text: string,
    config: GameScorerConfig,
    score: number,
    context: FlowContext,
  ): Promise<void> {
    try {
      await this.prisma.nluTrainingData.create({
        data: {
          text,
          intent: config.expectedIntent,
          language: this.detectLanguage(text),
          source: 'training_game',
          user_id: context._system.userId || context._system.phoneNumber,
          session_id: context._system.sessionId,
          quality_score: score,
          mission_type: config.missionType,
          metadata: {
            score,
            mission: config.missionType,
            timestamp: new Date().toISOString(),
          },
        },
      });

      this.logger.log(`‚úÖ Training data saved: ${text.substring(0, 50)}... (${score}/100)`);
    } catch (error) {
      this.logger.error(`Failed to save training data: ${error.message}`);
      // Don't fail the flow if DB save fails
    }
  }

  /**
   * Detect language
   */
  private detectLanguage(text: string): string {
    const hasHindi = /[\u0900-\u097F]/.test(text) || 
                     /chahiye|mangwa|bhej|kaha|karo|hai/.test(text.toLowerCase());
    const hasEnglish = /[a-zA-Z]/.test(text);

    if (hasHindi && hasEnglish) return 'hinglish';
    if (hasHindi) return 'hi';
    if (hasEnglish) return 'en';
    return 'auto';
  }
}
